-- cancel data
DROP FUNCTION IF EXISTS set_asn_moves_as_cancel_training(varchar);
CREATE OR REPLACE FUNCTION set_asn_moves_as_cancel_training(_store_code character varying)
RETURNS void
LANGUAGE plpgsql
AS $$
    DECLARE
        locations record;
    BEGIN
        conn := 'dbname=kasumi_middleware port=5432 host=10.130.0.35 user=celery password=celeryadmin';
        RAISE notice 'TRIGER STATUS: Running cancel ASN moves';
        
        SELECT w.receipt_oc_picking_type_id as picking_type_id, default_location_src_id as location_id, default_location_dest_id as location_dest_id
        FROM stock_picking_type t JOIN stock_warehouse w ON t.id=w.receipt_oc_picking_type_id WHERE w.active=true AND w.store_code=_store_code LIMIT 1
        INTO locations;
        IF locations IS NULL THEN
            RAISE exception 'Can not find related warehouse %', _store_code;
        END IF;

        -- Update state of stock move
        UPDATE stock_move SET state='cancel' 
        WHERE origin='ASN_DATA' 
            AND location_dest_id=locations.location_dest_id 
            AND date::DATE<CURRENT_DATE
            AND middleware_id in 
                (
                    SELECT 
                        asn_data.id 
                    FROM
                        dblink('dbname=kasumi_middleware port=5432 host=10.130.0.35 user=celery password=celeryadmin',
                        format('SELECT id FROM asn_aggregation WHERE store_code=%L AND filename in (%L, %L)', _store_code, 'OR_HACINQ_20220915.CSV', 'OR_HACINQ_20220916.CSV')) 
                    AS asn_data (id bigint)
                );
        
        -- Update state stock move line
        UPDATE stock_move_line SET state='cancel' 
        WHERE reference='ASN_DATA' 
            AND location_dest_id=locations.location_dest_id 
            AND date::DATE<CURRENT_DATE
            AND middleware_id in 
                (
                    SELECT 
                        asn_data.id 
                    FROM
                        dblink('dbname=kasumi_middleware port=5432 host=10.130.0.35 user=celery password=celeryadmin',
                        format('SELECT id FROM asn_aggregation WHERE store_code=%L AND filename in (%L, %L)', _store_code, 'OR_HACINQ_20220915.CSV', 'OR_HACINQ_20220916.CSV')) 
                    AS asn_data (id bigint)
                );

        -- Update Quant for destination
        UPDATE stock_quant q SET quantity=quantity - asn_moves.product_uom_qty,
            reserved_quantity=reserved_quantity - asn_moves.product_uom_qty, write_date=NOW()
        FROM (SELECT product_id, location_dest_id, SUM(product_uom_qty) as product_uom_qty
            FROM stock_move
            WHERE origin='ASN_DATA' AND location_dest_id=locations.location_dest_id
                AND date::DATE<CURRENT_DATE AND state='cancel'
            GROUP BY product_id, location_dest_id) AS asn_moves
        WHERE q.product_id=asn_moves.product_id AND q.location_id=asn_moves.location_dest_id;

        -- Create new quant for destination if necessary
        INSERT INTO stock_quant (product_id, company_id, location_id, quantity, reserved_quantity,
            create_uid, create_date, write_uid, write_date)
        SELECT sm.product_id, 1, locations.location_dest_id, -1 * SUM(sm.product_uom_qty), -1 * SUM(sm.product_uom_qty), 1, NOW(), 1, NOW()
        FROM stock_move sm LEFT JOIN stock_quant q ON sm.product_id=q.product_id AND sm.location_dest_id=q.location_id
        WHERE origin='ASN_DATA' AND sm.location_dest_id=locations.location_dest_id
            AND date::DATE<CURRENT_DATE AND state='cancel' AND q.id IS NULL
        GROUP BY sm.product_id, sm.location_dest_id;

        -- Update quant for source location
        UPDATE stock_quant q SET quantity=quantity + asn_moves.product_uom_qty,
            reserved_quantity=reserved_quantity + asn_moves.product_uom_qty, write_date=NOW()
        FROM (SELECT product_id, location_id, SUM(product_uom_qty) as product_uom_qty
            FROM stock_move
            WHERE origin='ASN_DATA' AND location_id=locations.location_id
                AND date::DATE<CURRENT_DATE AND state='cancel'
            GROUP BY product_id, location_id) AS asn_moves
        WHERE q.product_id=asn_moves.product_id AND q.location_id=asn_moves.location_id;

        -- Create new quant for source location if necessary
        INSERT INTO stock_quant (product_id, company_id, location_id, quantity, reserved_quantity,
            create_uid, create_date, write_uid, write_date)
        SELECT sm.product_id, 1, locations.location_id, SUM(sm.product_uom_qty), 0, 1, NOW(), 1, NOW()
        FROM stock_move sm LEFT JOIN stock_quant q ON sm.product_id=q.product_id AND sm.location_id=q.location_id
        WHERE origin='ASN_DATA' AND sm.location_id=locations.location_id
            AND date::DATE<CURRENT_DATE AND state='cancel' AND q.id IS NULL
        GROUP BY sm.product_id, sm.location_id;

        TRUNCATE master_closing_asn_aggregation;

        INSERT INTO master_closing_asn_aggregation (middleware_id)
        SELECT middleware_id 
        FROM stock_move 
        WHERE origin='ASN_DATA' 
            AND date::DATE<CURRENT_DATE
            AND state = 'cancel';

        UPDATE master_closing_asn_aggregation SET store_code = _store_code;

    EXCEPTION
        WHEN OTHERS THEN
        RAISE exception 'Encountered an issue when updating stock move, stock move line, or stock quant';
    END;
$$;


------------------------------------------------
-- ==================================================================================
-- ftp_integration_asn/controller/middleware_controller/sql/prepare_asn_table.sql
-- ==================================================================================
DROP TABLE IF EXISTS asn_data;
CREATE TABLE asn_data(
    id bigserial,
    hac_ten_code varchar, 
    sku_code varchar, 
    item_mj varchar, 
    hac_qty numeric, 
    hac_bi varchar, 
    nohn_bi varchar, 
    createdate timestamp, 
    temp_torisk_code varchar, 
    code_mj varchar, 
    err varchar, 
    sale_consume varchar, 
    hac_tni_qty numeric, 
    hac_tni varchar, 
    ten_center_code varchar, 
    bai_tnk numeric, 
    ten_sir_gen_tnk numeric, 
    center_sir_gen_tnk numeric, 
    joken_mj varchar, 
    chushutu_date varchar, 
    tokbai_kikaku_no varchar, 
    error_msg varchar, 
    temp_torihiki_rj varchar, 
    maker_code varchar, 
    bunrui1_code varchar, 
    bunrui2_code varchar, 
    bunrui3_code varchar, 
    bunrui4_code varchar, 
    zei_ritu_code varchar, 
    sitei_hac_bi varchar, 
    sitei_nohn_bi varchar, 
    sitei_hac_tni_qty numeric, 
    sitei_hac_tni varchar, 
    sitei_bai_tnk numeric, 
    sitei_ten_sir_gen_tnk numeric, 
    sitei_sir_gen_tnk numeric, 
    sitei_torisk_code varchar, 
    sitei_buturyu_kbn varchar, 
    purchase varchar, 
    code_rj varchar, 
    sosin_ten_code varchar, 
    filename varchar,
    create_date timestamp default now(),
    stage integer default 1
)PARTITION BY LIST(stage);

CREATE TABLE asn_data_new_row PARTITION OF asn_data FOR VALUES IN (1);
CREATE TABLE asn_data_on_process_warehouse_db PARTITION OF asn_data FOR VALUES IN (2);
CREATE TABLE asn_data_done PARTITION OF asn_data FOR VALUES IN (3);

-- adding partition for cancel data and pending
CREATE TABLE asn_data_cancel PARTITION OF asn_data FOR VALUES IN (5);
CREATE TABLE asn_data_pending PARTITION OF asn_data FOR VALUES IN (4);

CREATE INDEX IF NOT EXISTS asn_data_create_date_idx ON asn_data(create_date);
CREATE INDEX IF NOT EXISTS asn_data_sku_code_idx ON asn_data(sku_code);
CREATE INDEX IF NOT EXISTS asn_data_hac_bi_idx ON asn_data(hac_bi);
CREATE INDEX IF NOT EXISTS asn_data_nohn_bi_idx ON asn_data(nohn_bi);
CREATE INDEX IF NOT EXISTS asn_data_createdate_idx ON asn_data(createdate);
CREATE INDEX IF NOT EXISTS asn_data_temp_torisk_code_idx ON asn_data(temp_torisk_code);
CREATE INDEX IF NOT EXISTS asn_data_sosin_ten_code_idx ON asn_data(sosin_ten_code);
CREATE INDEX IF NOT EXISTS asn_data_filename_idx ON asn_data(filename);


-- ==================================================================================
-- ftp_integration_asn/controller/middleware_controller/sql/asn_integration_middleware.sql
-- ==================================================================================
DROP TABLE IF EXISTS asn_aggregation;
CREATE TABLE asn_aggregation(
    id bigserial,
    sku_code varchar(20),
    store_code varchar(20),
    move_date date,
    product_uom_qty float,
    filename varchar,
    create_date timestamp default now(),
    stage int default 1
) PARTITION BY LIST (stage);

CREATE TABLE asn_aggregation_to_process PARTITION OF asn_aggregation FOR VALUES IN (1);
CREATE TABLE asn_aggregation_processed PARTITION OF asn_aggregation FOR VALUES IN (2);
CREATE TABLE asn_aggregation_done PARTITION OF asn_aggregation FOR VALUES IN (3);
CREATE TABLE asn_aggregation_cancel PARTITION OF asn_aggregation FOR VALUES IN (5);
CREATE TABLE asn_aggregation_pending PARTITION OF asn_aggregation FOR VALUES IN (4);

CREATE INDEX IF NOT EXISTS asn_aggregation_stage ON asn_aggregation(stage);
CREATE INDEX IF NOT EXISTS asn_aggregation_sku_code ON asn_aggregation(sku_code);
CREATE INDEX IF NOT EXISTS asn_aggregation_store_code ON asn_aggregation(store_code);
CREATE INDEX IF NOT EXISTS asn_aggregation_date ON asn_aggregation(move_date);

DROP FUNCTION IF EXISTS generate_asn_aggregation_data();
CREATE OR REPLACE FUNCTION generate_asn_aggregation_data()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        RAISE notice 'TRIGER STATUS: Running Generate ASN Summary';
        
        -- insert into aggregation table
        INSERT INTO asn_aggregation (sku_code, store_code, move_date, product_uom_qty, filename)
        SELECT sku_code, hac_ten_code, nohn_bi::DATE, SUM(asn.hac_qty) * SUM(asn.hac_tni_qty) AS product_uom_qty, filename
        FROM asn_data_new_row asn
        WHERE asn.nohn_bi::DATE > (now() + interval '9 hours')::date
        GROUP BY sku_code, hac_ten_code, asn.nohn_bi, filename;

        -- update master data
        UPDATE asn_data SET stage=2 WHERE stage=1 AND asn_data.nohn_bi::DATE > (now() + interval '9 hours')::date;
    END;
$$;



-- ==================================================================================
-- ftp_integration_receipt_oc/controller/middleware_controller/sql/receipt_oc_asn.sql
-- ==================================================================================
CREATE TABLE receipt_oc_pending_data PARTITION OF receipt_oc FOR VALUES IN (4);
CREATE TABLE receipt_oc_cancel_data PARTITION OF receipt_oc FOR VALUES IN (5);
CREATE TABLE receipt_oc_skip_data PARTITION OF receipt_oc FOR VALUES IN (6);

-- Set Receipt OC as Pending
DROP FUNCTION IF EXISTS pending_receipt_oc();
CREATE OR REPLACE FUNCTION pending_receipt_oc()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        -- Pending --> nohn_bi is today or nohn_bi > today
        UPDATE receipt_oc SET stage=4 WHERE stage = 1 AND nohn_bi::DATE >= (now() + interval '9 hours')::date;
    END;
$$;

DROP FUNCTION IF EXISTS skip_receipt_oc();
CREATE OR REPLACE FUNCTION skip_receipt_oc()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        WITH todo as (
            SELECT r.id 
            FROM receipt_oc r
            JOIN inventory_adjustment_latest i ON (r.nyuka_sku_code=i.product_code AND r.nyuka_ten_code=i.store_code)
            WHERE stage = 1 AND r.nohn_bi::DATE < (now() + interval '9 hours')::date 
                AND (i.inventory_date::DATE >= r.nohn_bi::DATE)
                AND r.nyuka_ten_code IS NOT NULL
        )
        UPDATE receipt_oc r SET stage=5 FROM todo WHERE r.id = todo.id and stage = 1;
        
        WITH todo as (
            SELECT r.id 
            FROM receipt_oc r
            JOIN inventory_adjustment_latest i ON (r.shuka_sku_code=i.product_code AND r.shuka_ten_code=i.store_code)
            WHERE stage = 1 AND r.nohn_bi::DATE < (now() + interval '9 hours')::date 
                AND (i.inventory_date::DATE >= r.nohn_bi::DATE)
                AND r.shuka_ten_code IS NOT NULL
        )
        UPDATE receipt_oc r SET stage=5 FROM todo WHERE r.id = todo.id and stage = 1;
    END;
$$;

-- Resume Pending Receipt OC
DROP FUNCTION IF EXISTS resume_pending_receipt_oc();
CREATE OR REPLACE FUNCTION resume_pending_receipt_oc()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        -- Resume --> nohn_bi is less than today and nohn_bi is not less than last adjustment date
        WITH todo AS (
            SELECT r.id
            FROM receipt_oc r
            LEFT JOIN inventory_adjustment_latest i ON (r.nyuka_sku_code=i.product_code OR r.shuka_sku_code=i.product_code) AND (r.nyuka_ten_code=i.store_code OR r.shuka_ten_code=i.store_code)
            WHERE stage=4 
                AND r.nohn_bi::DATE < (now() + interval '9 hours')::date 
                AND r.nohn_bi::DATE > i.inventory_date::DATE
        )
        UPDATE receipt_oc r SET stage=1 FROM todo WHERE r.id=todo.id;
        
        
    END;
$$;

-- Cancel Receipt OC
DROP FUNCTION IF EXISTS cancel_receipt_oc();
CREATE OR REPLACE FUNCTION cancel_receipt_oc()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        -- Cancel --> nohn_bi is < today and the last stocktaking date more than or same nohn_bi
        WITH todo AS (
            SELECT r.id
            FROM receipt_oc r
            LEFT JOIN inventory_adjustment_latest i ON (r.nyuka_sku_code=i.product_code OR r.shuka_sku_code=i.product_code) AND (r.nyuka_ten_code=i.store_code OR r.shuka_ten_code=i.store_code)
            WHERE stage=1 
                AND r.nohn_bi::DATE < (now() + interval '9 hours')::date 
                AND r.nohn_bi::DATE <= i.inventory_date::DATE
        )

        UPDATE receipt_oc r SET stage=5 FROM todo WHERE r.id=todo.id;

    END;
$$;

-- receipt_oc process
DROP FUNCTION IF EXISTS process_receipt_oc_on_process();
CREATE OR REPLACE FUNCTION public.process_receipt_oc_on_process()
RETURNS VOID
LANGUAGE plpgsql AS
$$
    BEGIN
    -- insert into shuka_ten_code row
    -- If nohn_bi is < today and the last stocktaking date less than nohn_bi

    INSERT INTO receipt_oc(
        receipt_oc_middleware_id, syori_date, den_betu_code, den_no, den_eda_no,
        den_gyo_no, shuka_ten_code, nohn_bi, shuka_bunrui1_code, shuka_sku_code, shuka_scan_code,
        nyuka_bunrui1_code, nyuka_sku_code, nyuka_scan_code, item_rj, item_kbn, kazei_kbn,
        qty, sir_hon_gen_tnk, sir_gnk_kin, sir_hon_bai_tnk, sir_bika_kin, create_date,
        sync_metabase_stock_balance, filename, trans_type
    )
    SELECT
        id, syori_date, den_betu_code, den_no, den_eda_no, den_gyo_no, shuka_ten_code,
        nohn_bi, shuka_bunrui1_code,
        shuka_sku_code_normalize, shuka_scan_code, nyuka_bunrui1_code,
        nyuka_sku_code, nyuka_scan_code, item_rj, item_kbn, kazei_kbn, qty,
        sir_hon_gen_tnk, sir_gnk_kin, sir_hon_bai_tnk, sir_bika_kin, create_date,
        sync_metabase_stock_balance, filename, 'out' as trans_type
        FROM (select *, case when shuka_sku_code is null or shuka_sku_code = '' then shuka_sku_code else 
                shuka_sku_code::float::int::varchar end as shuka_sku_code_normalize from receipt_oc_csv) r
        LEFT JOIN inventory_adjustment_latest i ON shuka_sku_code_normalize=i.product_code AND r.shuka_ten_code=i.store_code
        WHERE stage = 1 ;
--         AND r.nohn_bi::DATE < (now() + interval '9 hours')::date AND 
--         (r.nohn_bi::DATE > i.inventory_date::DATE OR i.inventory_date is null);

--     UPDATE receipt_oc_csv 
--     SET stage = 2 
--     WHERE id in (SELECT id 
--                 FROM (select *, case when shuka_sku_code is null or shuka_sku_code = '' then shuka_sku_code else 
--                 	shuka_sku_code::float::int::varchar end as shuka_sku_code_normalize from receipt_oc_csv) r
--                 LEFT JOIN inventory_adjustment_latest i ON shuka_sku_code_normalize=i.product_code AND r.shuka_ten_code=i.store_code
--                 WHERE stage = 1 AND r.nohn_bi::DATE < (now() + interval '9 hours')::date AND 
--                     (r.nohn_bi::DATE > i.inventory_date::DATE OR i.inventory_date is null));
    -- insert into nyuka_ten_code row
    -- If nohn_bi is < today and the last stocktaking date less than nohn_bi
    INSERT INTO receipt_oc(
        receipt_oc_middleware_id, syori_date, den_betu_code, den_no, den_eda_no,
        den_gyo_no, nyuka_ten_code, nohn_bi, shuka_bunrui1_code, shuka_sku_code, shuka_scan_code,
        nyuka_bunrui1_code, nyuka_sku_code, nyuka_scan_code, item_rj, item_kbn, kazei_kbn,
        qty, sir_hon_gen_tnk, sir_gnk_kin, sir_hon_bai_tnk, sir_bika_kin, create_date,
        sync_metabase_stock_balance, filename, trans_type
    )
    SELECT
        id, syori_date, den_betu_code, den_no, den_eda_no, den_gyo_no, nyuka_ten_code,
        nohn_bi, shuka_bunrui1_code, shuka_sku_code, shuka_scan_code, nyuka_bunrui1_code,
        nyuka_sku_code, nyuka_scan_code, item_rj, item_kbn, kazei_kbn, qty,
        sir_hon_gen_tnk, sir_gnk_kin, sir_hon_bai_tnk, sir_bika_kin, create_date,
        sync_metabase_stock_balance, filename, 'in' as trans_type
    FROM receipt_oc_csv r
    LEFT JOIN inventory_adjustment_latest i ON r.nyuka_sku_code=i.product_code AND r.nyuka_ten_code=i.store_code
    WHERE stage = 1 ;
    -- AND r.nohn_bi::DATE < (now() + interval '9 hours')::date AND r.nohn_bi::DATE > i.inventory_date::DATE;

    UPDATE receipt_oc_csv 
    SET stage = 2 
    WHERE stage = 1;
    -- id in (SELECT id 
    --             FROM receipt_oc_csv r
    --             LEFT JOIN inventory_adjustment_latest i ON r.nyuka_sku_code=i.product_code AND r.nyuka_ten_code=i.store_code
    --             WHERE stage = 1 AND r.nohn_bi::DATE < (now() + interval '9 hours')::date AND r.nohn_bi::DATE > i.inventory_date::DATE);
    END;
$$;

-- ==================================================================================
-- ftp_integration_inventory_adjustment/controller/middleware_controller/sql/inventory_adjustment_latest.sql
-- ==================================================================================
DROP TABLE IF EXISTS inventory_adjustment_latest;
CREATE TABLE inventory_adjustment_latest(
    product_code varchar,
    store_code varchar,
    inventory_date varchar,
    UNIQUE(product_code, store_code)
);

-- Fill table inventory_adjustment_latestn
DROP FUNCTION IF EXISTS update_inventory_adjustment_latest();
CREATE OR REPLACE FUNCTION update_inventory_adjustment_latest()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        INSERT INTO inventory_adjustment_latest
            SELECT product_code, store_code, inventory_date
            FROM inventory_adjustment_temp
            WHERE stage in (2,3) AND inventory_date::DATE >= (now() + interval '9 hours')::date
        ON CONFLICT (product_code, store_code)
        DO UPDATE
            SET inventory_date=EXCLUDED.inventory_date;
    END;
$$;


DROP FUNCTION IF EXISTS get_older_inventory_adjustment_latest();
CREATE OR REPLACE FUNCTION get_older_inventory_adjustment_latest()
RETURNS void
LANGUAGE plpgsql
AS $$
    BEGIN
        INSERT INTO inventory_adjustment_latest
        SELECT product_code, store_code, max(inventory_date)
        FROM inventory_adjustment_temp
        WHERE stage in (2,3)
        GROUP BY product_code, store_code
        ON CONFLICT (product_code, store_code)
        DO UPDATE
            SET inventory_date=EXCLUDED.inventory_date;
    END;
$$;



SELECT pp.default_code, round(odoo.qty,1), round(initial.quantity::numeric, 1) as initial_qty from stock_quant initial
    full outer join (SELECT product_id,
    coalesce(sum(case when src_loc.usage != 'internal' and dest_loc.usage = 'internal' 
    then move.qty_done else 0 end), 0) -
    coalesce(sum(case when src_loc.usage = 'internal' and dest_loc.usage != 'internal'
    then move.qty_done else 0 end), 0) as qty
FROM stock_move_line move join product_product pp on pp.id = product_id
    join stock_location src_loc on src_loc.id = move.location_id
    join stock_location dest_loc on dest_loc.id = move.location_dest_id
WHERE ((move.location_id in (select id from stock_location where usage not in ('internal', 'view', 'transit')) or
    move.location_id in (select id from stock_location where usage in ('transit', 'internal'))) 
                     or
    (move.location_dest_id in (select id from stock_location where usage not in  ('internal', 'view', 'transit')) or
    move.location_id in (select id from stock_location where usage in ('transit', 'internal'))))
                     
    and move.state = 'done'
group by product_id) as odoo ON odoo.product_id = initial.product_id join product_product pp on pp.id = initial.product_id
where quantity != 0 and initial.product_id is not null and (round(odoo.qty,1) != round(initial.quantity::numeric, 1)) = true limit 10;






a or b and c

